---
title: "Vertical Contagion"
author: "Nicolas Restrepo"
date: "5/3/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Get the packages we need 
library(tidyverse)
library(igraph)
library(brainGraph)
library(patchwork)
library(bayestestR)
library(netrankr)
library(ggrepel)
library(corrplot)
```

## Introduction 

Here, I am going to be building a contagion model, where agents can only acquire the trait from those who are older than them. This requires relatively minimal edits to the contagion simulation we had been using so far. 

The key piece of information here is age. We have age for the dolphin data. I will adapt the function to build the dolphin networks so that it returns age as a node attribute. 

```{r}
# Write function to return the graph from a wave
# This time I want age in there 
dolphin_edgelist <- function(w, t, node_file) {
  if (w == 1) {
    c <- "T2008"
    title <- "Wave 1"
    current_time <- as.Date("2008-12-31")
  } else {
    if(w ==2) {
      c <- "T2010"
      title <- "Wave 2"
      current_time <- as.Date("2010-12-31")
    } else {
      if (w==3) {
        c <- "T2012"
        title <- "Wave 3"
        current_time <- as.Date("2012-12-31")
      } else {
        if (w == 4) {
          c <- "T2014"
          title <- "Wave 4"
          current_time <- as.Date("2014-12-31")
        } else {
          if (w == 5) {
            c <- "T2016"
            title <- "Wave 5"
            current_time <- as.Date("2016-12-31")
          } else {
            c <- "T2018"
            title <- "Wave 6"
            current_time <- as.Date("2018-12-31")
          }
        }
      }
    }
  }
  # Take the wave 
  edgelist <- dolphin_edge_lists %>% 
    select(1,2, c, 9) %>% 
    filter(!is.na(.[,3]) & .[,3] > t) %>% 
    rename(weight = c, 
           from = ID1, 
           to = ID2)
  node_file$Birth.Date <- as.Date(node_file$Birth.Date)
  node_file$age <- current_time-node_file$Birth.Date
  
  net <- graph_from_data_frame(edgelist, directed = FALSE)
  df_ordered_nodes <- tibble(Dolphin.ID = V(net)$name)
  df_ordered_nodes <- df_ordered_nodes %>% 
    left_join(node_file, by = "Dolphin.ID")
  
  V(net)$age <- df_ordered_nodes$age
  return(net)
}

```

Now, I am going to build the network for wave 1 (including age). 

```{r}
# Now let's read the data in 
# Edgelist
dolphin_edge_lists <- read_csv("Data/dolphin_edge_lists.csv")
# Attribute file
id_list <- read_csv("Data/ID_list.csv")

# Get the network 
dolphin_w1 <- dolphin_edgelist(w = 1, 
                              t = 0, 
                              node_file = id_list)

```

Let's now adapt our contagion simulation so that the spread can only spread if the current carrier is older than a potential receiver. 

```{r}
# Now write function for vertical social learning
info_contagion_vertical <- function(net, rewire, e = 1, r_max, sim = 1){
  
  # Rewire network if random is set to TRUE
  if(rewire){
    net <- rewire(graph = net, with = keeping_degseq(loops = F, niter = 10^3))
  }
  
  # Get adjacency matrix from network
  adjm <- get.adjacency(net, 
                        sparse = F, 
                        attr = "weight")
  mat_inv <- adjm 
  edges <- which(mat_inv > 0)
  mat_inv[edges] <- 1.0001 - mat_inv[edges]
  inv_network <- graph_from_adjacency_matrix(mat_inv,
                                             mode = "undirected",
                                             weighted = TRUE)
  bcent <- betweenness(net, directed = FALSE, weights = E(inv_network)$weight)
  
  # Turn adjacency matrix into boolean (TRUE / FALSE) - if you dont want weights
  # adjm_bool <- adjm > 0
  
  # Set number of individuals based adjacency matrix
  N <- vcount(net)
  
  # Create a vector indicating possession of info and set one entry to TRUE
  info <- rep(FALSE, N)
  info[which.max(bcent)] <- TRUE
  
  # Create a reporting variable
  proportion <- rep(0, r_max)
  ages <- V(net)$age
  # Rounds
  for(r in 1:r_max){
    # In random sequence go through all individuals without info
    for(i in sample(N)){
      # Select i's neighbourhood 
      ties <- adjm[i,] > 0
      nei <- ties & ages > ages[i]
      # If you dont want to include weights, quote above, unquote below
      #nei <- adjm_bool[i,]
      # Proceed if there is at least one neighbour
      if(sum(nei) > 0){
        # Simple contagion for e = 1 and complex contagion for e = 2
        if(runif(n = 1, min = 0, max = 1) <= (sum(adjm[i,which(nei & info)])/sum(nei))^e){
          info[i] <- TRUE
        }
      }
    }
    # Record proportion of the population with info
    proportion[r] <- sum(info) / N
    # Increment the round counter
    r <- r + 1
  }
  # Return a tibble with simulation results
  return(tibble(time = 1:r_max, 
                proportion = proportion, 
                time_to_max = which(proportion == max(proportion))[1],
                e = e, 
                network = ifelse(test = rewire, yes = "random", no = "model output"),
                sim = sim))
}

```

I'll begin by exploring if random removal changes the trajectories of diffusion. I suspect that the values will swing wildly - certain removals will make contagion more efficient and vice versa. There is a further element of arbitrariness here which is the age of the node that is initially seeded. So wild fluctuations might be due to that as opposed to the structure's capacity to transmit information. 

```{r}
set.seed(3376)
# What about after some random removal 
rmv <- sample(1:vcount(dolphin_w1), 10)
ng <- delete.vertices(dolphin_w1, rmv)

multiple_diff_auc <- function(ev, g, g2, reps, turns) {
  # Place holder 
  values <- rep(NA, reps)
  
  for (i in 1:reps) {
    sim <- info_contagion_vertical(g, 
                          rewire = F, 
                          e = ev, 
                          r_max = turns)
    auc_nr <- area_under_curve(x = sim$time, 
                               y = sim$proportion)
    
    # Now with removal
    sim_r <- info_contagion_vertical(g2, 
                            rewire = F, 
                            e = ev, 
                            r_max = turns)
    auc_r <- area_under_curve(x = sim_r$time, 
                              y = sim_r$proportion)
    
    diff <- auc_r/auc_nr
    
    values[i] <- diff
  }
  return(values)
}
auc_diffs_targeted <- multiple_diff_auc(ev = 1, 
                                        g = dolphin_w1, 
                                        g2 = ng,
                                        reps = 100, 
                                        turns = 500)
tibble(run = 1:100, 
       difference = auc_diffs_targeted) %>% 
  ggplot(aes(x = difference)) +
  geom_density() + 
  geom_vline(xintercept = median(auc_diffs_targeted), 
             lty = 2, 
             color = "red") + 
  geom_text(x = median(auc_diffs_targeted)-0.03, y = 1, 
            label = as.character(round(median(auc_diffs_targeted), 2)), 
            color = "red") +
  theme_bw() +
  labs(title = "Ratio of areas under the curve", 
       subtitle = "random removal", 
       x = "Ratio", 
       y = "")

```

There is a lot of variance here, as we expected. But the median here was below one. I personally did not expect this. Let's see what happens when we remove the most central nodes. 

```{r}
set.seed(33)
inverse_efficiency <- function(g) {
  # Turn it into an adjacency matrix 
  net_mat <- as_adj(g,
                    attr = 'weight', 
                    sparse = F)
  # Get the inverse matrix 
  mat_inv <- net_mat 
  edges <- which(mat_inv > 0)
  mat_inv[edges] <- 1.0001 - mat_inv[edges]
  # Populate the diagonal with 0s
  diag(mat_inv) <- 0
  
  # Create the new graph 
  net_inv <- graph_from_adjacency_matrix(mat_inv, 
                                         weighted = T, 
                                         mode = 'undirected')
  D <- distances(net_inv, 
                 weights = E(net_inv)$weight)
  D <- D + 1 
  diag(D) <- 0
  Nv <- nrow(D)
  Dinv <- 1/D
  eff <- colSums(Dinv * is.finite(Dinv), na.rm = T)/(Nv - 1)
  geff <- sum(eff)/length(eff)
  
  return(geff)
}
decrease_efficiency <- function(g) {
  # Get the original efficiency
  og_geff <- inverse_efficiency(g)
  # A matrix to store the data
  removal_df <- matrix(NA, ncol = 7, nrow = length(V(g)))
  # Inverse network 
  net_mat <- as_adj(g, 
                    attr = "weight",
                    sparse = FALSE)
  # Get the inverse matrix 
  mat_inv <- net_mat 
  edges <- which(mat_inv > 0)
  mat_inv[edges] <- 1.0001 - mat_inv[edges]
  inv_network <- graph_from_adjacency_matrix(mat_inv,
                                             mode = "undirected",
                                             weighted = TRUE)
  for (i in 1:length(V(g))) {
    vert <- V(g)[i]
    deg <- degree(g)[vert]
    ecent <- eigen_centrality(g, weights = E(g)$weight)$vector[vert]
    bcent <- betweenness(g, directed = FALSE, weights = E(inv_network)$weight)[vert]
    bonacich_cent <- power_centrality(g, exponent = 1, rescale = T)[vert]
    net_mat <- as_adj(g, attr = 'weight', sparse = F)
    sum_weigths <- sum(net_mat[vert,], na.rm = T)
    ng <- delete.vertices(g, vert)
    eff <- inverse_efficiency(ng)
    removal_df[i,] <- c(names(vert), 
                        eff-og_geff,
                        deg,
                        sum_weigths, 
                        ecent, 
                        bcent, 
                        bonacich_cent)
  }
  
  removal_df <- data.frame(removal_df)
  names(removal_df) <- c("node_name", "change_efficiency",
                         "degree", "sum_edge_weights", 
                         "eigen_centrality", 
                         "betweenness", 
                         "bonacich")
  removal_df <- removal_df %>% 
    mutate_at(vars(-("node_name")),as.numeric)
  
  # Build an edgelist to find family ties
  edgelist <- get.data.frame(g)
  
  # See which lines fullfil the requirements for kinship ties
  kinship_ties <- rep(NA, nrow(edgelist))
  
  for (i in 1:nrow(edgelist)) {
    pat_from <- edgelist$from[i]
    if (str_detect(edgelist$to[i], "\\.") != TRUE) {
      kinship_ties[i] <- 0
    } else {
      pat_to <- sub("\\..*", "", edgelist$to[i])
      if (pat_from==pat_to) {
        kinship_ties[i] <- 1
      } else {
        kinship_ties[i] <- 0
      }
    }
  }
  
  edgelist$kinship <- kinship_ties
  
  mothers <- edgelist %>% 
    filter(kinship==1) %>% 
    pull(from)
  
  children <- edgelist %>% 
    filter(kinship==1) %>% 
    pull(to)
  
  removal_df <- removal_df %>% 
    mutate(mothers = if_else(node_name %in% mothers, 1, 0), 
           children = if_else(node_name %in% children, 1, 0))
  
  removal_df <- removal_df %>% 
  mutate_at(.vars = c("change_efficiency",
                      "degree", "sum_edge_weights", 
                      "eigen_centrality", 
                      "betweenness", 
                      "bonacich"), 
            as.numeric)
  
  
  return(removal_df)
}

# First removal
removal_ed_w1_one <- decrease_efficiency(dolphin_w1)

# Network with centrality removals 
central_nodes_dd_w1 <- removal_ed_w1_one %>% 
  arrange(desc(betweenness)) %>% 
  slice(1:10) %>% 
  pull(node_name)
# Remove the vertex with highest centrality 
dd_w1_central_rems <- delete.vertices(dolphin_w1, V(dolphin_w1)[central_nodes_dd_w1])


auc_diffs_central <- multiple_diff_auc(ev = 1, 
                                        g = dolphin_w1, 
                                        g2 = dd_w1_central_rems,
                                        reps = 100, 
                                        turns = 500)
tibble(run = 1:100, 
       difference = auc_diffs_central) %>% 
  ggplot(aes(x = difference)) +
  geom_density() + 
  geom_vline(xintercept = median(auc_diffs_central), 
             lty = 2, 
             color = "red") + 
  geom_text(x = median(auc_diffs_central)-0.03, y = 1, 
            label = as.character(round(median(auc_diffs_central), 2)), 
            color = "red") +
  theme_bw() +
  labs(title = "Ratio of areas under the curve", 
       subtitle = "centrality removal", 
       x = "Ratio", 
       y = "")

```

Here the mean is also below zero. 

Can I think about how to look at oldest removals? 

```{r}
removal_ed_w1_one$age <- V(dolphin_w1)$age

oldest <- removal_ed_w1_one %>% 
  select(node_name, age) %>% 
  arrange(desc(age)) %>% 
  pull(node_name)

info_contagion_vertical_oldest <- function(net, 
                                           rewire, 
                                           e = 1, 
                                           r_max, 
                                           sim = 1){
  
  # Rewire network if random is set to TRUE
  if(rewire){
    net <- rewire(graph = net, with = keeping_degseq(loops = F, niter = 10^3))
  }
  
  # Get adjacency matrix from network
  adjm <- get.adjacency(net, 
                        sparse = F, 
                        attr = "weight")
  
  # Turn adjacency matrix into boolean (TRUE / FALSE) - if you dont want weights
  # adjm_bool <- adjm > 0
  
  # Set number of individuals based adjacency matrix
  N <- vcount(net)
  
  # Create a vector indicating possession of info and set one entry to TRUE
  info <- rep(FALSE, N)
  info[80] <- TRUE
  
  # Create a reporting variable
  proportion <- rep(0, r_max)
  
  # Rounds
  for(r in 1:r_max){
    # In random sequence go through all individuals without info
    for(i in sample(N)){
      # Select i's neighbourhood 
      ties <- adjm[i,] > 0
      nei <- ties & V(net)$age > V(net)$age[i]
      # If you dont want to include weights, quote above, unquote below
      #nei <- adjm_bool[i,]
      # Proceed if there is at least one neighbour
      if(sum(nei) > 0){
        # Simple contagion for e = 1 and complex contagion for e = 2
        if(runif(n = 1, min = 0, max = 1) <= (sum(adjm[i,which(nei & info)])/sum(nei))^e){
          info[i] <- TRUE
        }
      }
    }
    # Record proportion of the population with info
    proportion[r] <- sum(info) / N
    # Increment the round counter
    r <- r + 1
  }
  # Return a tibble with simulation results
  return(tibble(time = 1:r_max, 
                proportion = proportion, 
                time_to_max = which(proportion == max(proportion))[1],
                e = e, 
                network = ifelse(test = rewire, yes = "random", no = "model output"),
                sim = sim))
}

dd_w1_oldest_rems <- delete.vertices(dolphin_w1, 
                                      V(dolphin_w1)[oldest[2:11]])

olds_rems <- info_contagion_vertical_oldest(dd_w1_oldest_rems, 
                               rewire = F, 
                               r_max = 500)
```

Let's look at targeted removals: 

```{r}

# Network with centrality removals 
targeted_nodes_dd_w1 <- removal_ed_w1_one %>% 
  arrange(change_efficiency) %>% 
  slice(1:10) %>% 
  pull(node_name)
# Remove the vertex with highest centrality 
dd_w1_targ_rems <- delete.vertices(dolphin_w1, V(dolphin_w1)[targeted_nodes_dd_w1])

auc_diffs_targeted <- multiple_diff_auc(ev = 1, 
                                        g = dolphin_w1, 
                                        g2 = dd_w1_targ_rems,
                                        reps = 100, 
                                        turns = 500)
```

